# `kill 与 kill -9`

需要特别说明的是，`SIGKILL` 和 `SIGSTOP` 这两个信号既不能被应用程序捕获，也不能被操作系统阻塞或忽略。

## 1. `kill pid` 与 `kill -9 pid` 的区别

`kill pid` 的作用是向进程号为pid的进程发送 `SIGTERM`（这是kill默认发送的信号），该信号是一个结束进程的信号且可以被应用程序捕获。若应用程序没有捕获并响应该信号的逻辑代码，则该信号的默认动作是kill掉进程。这是终止指定进程的推荐做法。  

`kill -9 pid` 则是向进程号为 `pid` 的进程发送 `SIGKILL`（该信号的编号为9），从本文上面的说明可知，`SIGKILL` 既不能被应用程序捕获，也不能被阻塞或忽略，其动作是立即结束指定进程。通俗地说，应用程序根本无法“感知”SIGKILL信号，它在完全无准备的情况下，就被收到 `SIGKILL` 信号的操作系统给干掉了，显然，在这种“暴力”情况下，应用程序完全没有释放当前占用资源的机会。事实上，`SIGKILL`信号是直接发给`init`进程的，它收到该信号后，负责终止 `pid` 指定的进程。在某些情况下（如进程已经 `hang` 死，无法响应正常信号），就可以使用 `kill -9` 来结束进程。  

若通过 `kill` 结束的进程是一个创建过子进程的父进程，则其子进程就会成为孤儿进程 `（Orphan Process）`，这种情况下，子进程的退出状态就不能再被应用进程捕获（因为作为父进程的应用程序已经不存在了），不过应该不会对整个 `linux` 系统产生什么不利影响。

## 2. 应用程序如何优雅退出

Linux Server端的应用程序经常会长时间运行，在运行过程中，可能申请了很多系统资源，也可能保存了很多状态，在这些场景下，我们希望进程在退出前，可以释放资源或将当前状态dump到磁盘上或打印一些重要的日志，也就是希望进程优雅退出`（exit gracefully）`。
从上面的介绍不难看出，优雅退出可以通过捕获SIGTERM来实现。具体来讲，通常只需要两步动作：  

1. 注册SIGTERM信号的处理函数并在处理函数中做一些进程退出的准备。信号处理函数的注册可以通过signal()或sigaction()来实现，其中，推荐使用后者来实现信号响应函数的设置。信号处理函数的逻辑越简单越好，通常的做法是在该函数中设置一个bool型的flag变量以表明进程收到了SIGTERM信号，准备退出。
1. 在主进程的main()中，通过类似于while(!bQuit)的逻辑来检测那个flag变量，一旦bQuit在signal handler function中被置为true，则主进程退出while()循环，接下来就是一些释放资源或dump进程当前状态或记录日志的动作，完成这些后，主进程退出。

> <http://www.2cto.com/os/201305/215267.html>
